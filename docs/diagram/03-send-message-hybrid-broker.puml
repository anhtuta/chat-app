@startuml

header "Send message flow with Hybrid Broker (In-Memory + RabbitMQ)"
footer "Author: Tuzaku"

actor User1
participant "WebApp 1\n(Client)" as WebApp1
participant "Spring Boot\nInstance 1" as App1
participant "SimpleBroker\n(In-Memory)" as SimpleBroker
participant "RabbitMQ\nSubscription\nInterceptor" as SubInterceptor
participant "CustomRabbitMQ\nBrokerHandler" as RabbitHandler
participant "RabbitMQ\nBroker" as RabbitMQ
participant "DynamicRabbitMQ\nListener" as RabbitListener
participant "Spring Boot\nInstance 2" as App2
participant "DynamicRabbitMQ\nListener 2" as RabbitListener2
participant "SimpleBroker 2\n(In-Memory)" as SimpleBroker2
participant "WebApp 2\n(Client)" as WebApp2
database PostgreSQL

== STOMP SUBSCRIBE (Hybrid Approach) ==

note over WebApp1, RabbitMQ
  Subscription is registered in BOTH SimpleBroker (local) and RabbitMQ (cross-instance).
  Local subscribers means users who are connected to the same instance as the sender.
  Cross-instance subscribers means users who are connected to other instances.
  When a user sends a message, it will be sent to both local and cross-instance subscribers.
  Local subscribers will receive the message immediately.
  Cross-instance subscribers will receive the message after it is forwarded from RabbitMQ.
end note

WebApp1 -> App1: STOMP SUBSCRIBE to /topic/public
App1 -> SubInterceptor: preSend() - SUBSCRIBE command
SubInterceptor -> RabbitHandler: handleSubscribe("/topic/public")
RabbitHandler -> RabbitHandler: syncSubscriptionToRabbitMQ()
RabbitHandler -> RabbitMQ: Create exchange if not exists: topic.public

alt This is the first subscription
  note right of RabbitHandler
    Only create queue when it's the first subscription to this destination (/topic/public)
    (The first user sends StompCommand.SUBSCRIBE command to /topic/public)
  end note
  RabbitHandler -> RabbitMQ: Create queue: ws.instance-1.topic.public
  RabbitHandler -> RabbitMQ: Bind queue to FanoutExchange: topic.public
  RabbitHandler -> RabbitListener: startListening(queueName, destination)
  RabbitListener -> RabbitListener: Create a new listener/consumer
  RabbitListener -> RabbitMQ: Start consuming from queue
  RabbitMQ -> RabbitHandler: Queue created and bound
end

SubInterceptor -> App1: Allow SUBSCRIBE
App1 -> SimpleBroker: Register subscription (local)\n(Spring does this automatically)
SimpleBroker -> SimpleBroker: Add client to /topic/public subscribers\n(Spring does this automatically)
App1 -> WebApp1: Subscription confirmed

== Send Public Message (Hybrid Approach) ==

User1 -> WebApp1: Type and send message
WebApp1 -> App1: STOMP SEND to /app/chat.send
App1 -> App1: @MessageMapping("/chat.send")
App1 -> PostgreSQL: Save message
PostgreSQL -> App1: Saved message
App1 -> App1: Create MessageResponse

note over App1
  Message is sent to BOTH:
  1. SimpleBroker (for local subscribers)
  2. RabbitMQ (for cross-instance)
end note

App1 -> SimpleBroker: @SendTo("/topic/public") - MessageResponse
SimpleBroker -> SimpleBroker: Find local subscribers
SimpleBroker -> WebApp1: Broadcast MessageResponse (local clients)

App1 -> RabbitHandler: publishToRabbitMQ("/topic/public", MessageResponse)
RabbitHandler -> RabbitHandler: Add source-instance-id header
RabbitHandler -> RabbitMQ: Publish to FanoutExchange: topic.public
RabbitMQ -> RabbitMQ: Broadcast to all bound queues

note right of RabbitMQ
  Cross-Instance Message Delivery
end note

RabbitMQ -> RabbitListener: Message from queue (instance-1 queue)
RabbitListener -> RabbitListener: Check source-instance-id
note right of RabbitListener
  source-instance-id = instance-1
  current instance = instance-1
  Skip (same instance)
end note
RabbitListener -> RabbitListener: Skip message (same instance)

RabbitMQ -> RabbitListener2: Message from queue (instance-2 queue)
RabbitListener2 -> RabbitListener2: Check source-instance-id
note right of RabbitListener2
  source-instance-id = instance-1
  current instance = instance-2
  Forward to local subscribers
end note
RabbitListener2 -> RabbitListener2: Deserialize payload
RabbitListener2 -> SimpleBroker2: convertAndSend("/topic/public", payload)
SimpleBroker2 -> SimpleBroker2: Find local subscribers
SimpleBroker2 -> WebApp2: Broadcast MessageResponse (Instance 2 clients)

== Key Points ==

note right of SimpleBroker
  SimpleBroker handles:
  - Local WebSocket connections
  - Fast local message delivery
  - Per-instance subscription registry (subscriptions of that instance only)
end note

note right of RabbitMQ
  RabbitMQ handles:
  - Cross-instance message distribution
  - One queue per instance per destination
  - FanoutExchange broadcasts to all queues
end note

note right of RabbitHandler
  CustomRabbitMQBrokerHandler:
  - Syncs subscriptions to RabbitMQ (create/delete queues at the first/last subscription/unsubscription)
  - Publishes messages to RabbitMQ
end note

note right of RabbitListener
  DynamicRabbitMQListener:
  - Consumes from RabbitMQ queues
  - Filters self-delivery (source-instance-id)
  - Forwards to SimpleBroker for local delivery
end note

@enduml

